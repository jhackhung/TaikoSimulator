#include <SFML/Graphics.h>
#include <SFML/Window.h>
#include <SFML/System.h>
#include <SFML/Audio.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>  // 新增：用於strstr
#include <math.h>    // 新增：用於fabsf
#include <stdbool.h> // 新增：用於bool型別

#define MAX_NOTES 10000
#define MAX_LINE_LENGTH 1000
#define SCREEN_WIDTH 1280
#define SCREEN_HEIGHT 720
#define DRUM_SPEED 0.25
#define MAX_DRUMS 100
#define HIT_POSITION_X 450
#define GREAT_THRESHOLD 4
#define GOOD_THRESHOLD 32
#define INITIAL_DELAY 3.0f

typedef struct Drum {
    sfSprite* sprite;
    int type;
    float targetTime;
} Drum;

typedef struct {
    int great_count;
    int good_count;
    int miss_count;
    int current_combo;
    int max_combo;
    int total_score;
} GameStats;

typedef struct {
    float bpm;
    float offset;
    float spawnTime;  // 第一個音符的生成時間
    int currentBar;   // 目前處理到哪個小節
    int notesInBar;   // 目前小節的音符數量
} MusicInfo;

GameStats stats = { 0, 0, 0, 0, 0, 0 };

MusicInfo musicInfo = { 0 };

Drum drumQueue[MAX_DRUMS];
int front = 0;
int rear = 0;
int size = 0;
sfTexture* redDrumTexture;
sfTexture* blueDrumTexture;

int notes[MAX_NOTES];
float noteTimes[MAX_NOTES];
int totalNotes = 0;
float noteSpawnInterval;

void parseNoteChart(const char* filename) {
    FILE* file = fopen(filename, "r");
    if (!file) {
        printf("無法開啟檔案！\n");
        return;
    }

    char line[MAX_LINE_LENGTH];
    int inNoteSection = 0;
    totalNotes = 0;
    float currentTime = 0.0f;
    char* currentBar = NULL;

    while (fgets(line, sizeof(line), file)) {
		// 移除換行符號
        line[strcspn(line, "\n")] = 0;

        if (strncmp(line, "BPM:", 4) == 0) {  // 使用strncmp代替strstr
            sscanf_s(line, "BPM:%f", &musicInfo.bpm);
            continue;
        }

        if (strncmp(line, "OFFSET:", 7) == 0) {
            sscanf_s(line, "OFFSET:%f", &musicInfo.offset);
            continue;
        }

        if (strncmp(line, "#START", 6) == 0) {  // 使用strncmp代替strstr
            inNoteSection = 1;
            continue;
        }

        if (strncmp(line, "#END", 4) == 0) {  // 使用strncmp代替strstr
            break;
        }
        if (inNoteSection) {
            // 處理小節分割
            char* context;
            char* bar = strtok_s(line, ",", &context);
            while (bar) {
                while (*bar == ' ') bar++;

                // 計算這個小節的音符數
                int barLength = strlen(bar);
                int validNotes = 0;
                for (int i = 0; i < barLength; i++) {
                    if (bar[i] >= '0' && bar[i] <= '9') {
                        validNotes++;
                    }
                }

                if (validNotes > 0) {
                    // 處理每個音符
                    for (int i = 0; i < barLength; i++) {
                        if (bar[i] >= '1' && bar[i] <= '2') {
                            notes[totalNotes] = bar[i] - '0';
                            // 計算這個音符應該在什麼時間出現
                            float beatTime = 60.0f / musicInfo.bpm;  // 一拍的時間
                            float barTime = 4 * beatTime;  // 假設一小節是4拍
                            float noteTime = barTime / validNotes;  // 一個音符的時間
                            noteTimes[totalNotes] = musicInfo.currentBar * barTime +
                                (i * noteTime) +
                                musicInfo.offset;
                            totalNotes++;
						}
                        /*else if (bar[i] == '0') {
                            notes[totalNotes] = 0;
                            noteTimes[totalNotes] = 0;
                            totalNotes++;
                        }*/
                    }
                }
                musicInfo.currentBar++;
             
                bar = strtok_s(NULL, ",", &context);
            }
        }
    }

    fclose(file);
	noteSpawnInterval = 60000.0f / (musicInfo.bpm * 4.0f);  // 計算音符生成間隔
    printf("BPM: %f, 音符生成間隔: %f毫秒\n", musicInfo.bpm, noteSpawnInterval);
}

// Queue 操作函數保持不變...
int isQueueFull() {
    return size == MAX_DRUMS;
}

int isQueueEmpty() {
    return size == 0;
}

void enqueue(Drum drum) {
    if (isQueueFull()) {
        printf("Queue is full!\n");
        return;
    }
    drumQueue[rear] = drum;
    rear = (rear + 1) % MAX_DRUMS;
    size++;
}

void dequeue() {
    if (isQueueEmpty()) {
        printf("Queue is empty!\n");
        return;
    }
    sfSprite_destroy(drumQueue[front].sprite);
    front = (front + 1) % MAX_DRUMS;
    size--;
}

void spawnDrum(int type, float targetTime) {
    if (isQueueFull()) {
        printf("Queue is full, cannot spawn more drums!\n");
        return;
    }

    Drum drum;
    drum.type = type;
    drum.targetTime = targetTime;  // 設定目標時間

    drum.sprite = sfSprite_create();
    if (drum.type == 1) {
        sfSprite_setTexture(drum.sprite, redDrumTexture, sfTrue);
    }
    else {
        sfSprite_setTexture(drum.sprite, blueDrumTexture, sfTrue);
    }

    // 根據目標時間計算初始位置
    float initialX = SCREEN_WIDTH;
    sfSprite_setPosition(drum.sprite, (sfVector2f) { initialX, 200 });

    enqueue(drum);
}

void updateDrums(float currentTime) {
    if (size > 0) {
        // 檢查Miss判定
        float frontTime = drumQueue[front].targetTime;
        if (currentTime > frontTime + (GOOD_THRESHOLD / 1000.0f)) {
            stats.miss_count++;
            stats.current_combo = 0;
            dequeue();
            return;
        }

        // 更新所有音符的位置
        int count = size;
        int index = front;
        while (count > 0) {
            float noteTime = drumQueue[index].targetTime;
            float timeToHit = noteTime - currentTime;

            // 計算音符應該在的位置
            float targetX = HIT_POSITION_X - 46;  // 判定位置
            float distance = timeToHit * (DRUM_SPEED * 1000);  // 根據速度和時間計算距離
            float posX = targetX + distance;

            sfSprite_setPosition(drumQueue[index].sprite,
                (sfVector2f) {
                posX, 200
            });

            index = (index + 1) % MAX_DRUMS;
            count--;
        }
    }
}

sfCircleShape* createJudgementCircle() {
    sfCircleShape* circle = sfCircleShape_create();
    sfCircleShape_setRadius(circle, 30);
    sfCircleShape_setPosition(circle, (sfVector2f) { HIT_POSITION_X, 200 + 25 });
    sfCircleShape_setFillColor(circle, sfTransparent);
    sfCircleShape_setOutlineThickness(circle, 2);
    sfCircleShape_setOutlineColor(circle, sfBlack);
    return circle;
}

void processHit(int hitType, float currentTime) {
    if (size == 0) return;

    float noteTime = drumQueue[front].targetTime;
    float timeDiff = (float)fabs(currentTime - noteTime);  // 使用fabs代替fabsf

    if (drumQueue[front].type != hitType) {
        stats.miss_count++;
        stats.current_combo = 0;
        return;
    }

    if (timeDiff <= GREAT_THRESHOLD / 1000.0f) {
        stats.great_count++;
        stats.current_combo++;
        stats.total_score += 300 + (stats.current_combo * 10);
        if (stats.current_combo > stats.max_combo) {
            stats.max_combo = stats.current_combo;
        }
        dequeue();
    }
    else if (timeDiff <= GOOD_THRESHOLD / 1000.0f) {
        stats.good_count++;
        stats.current_combo++;
        stats.total_score += 100 + (stats.current_combo * 5);
        if (stats.current_combo > stats.max_combo) {
            stats.max_combo = stats.current_combo;
        }
        dequeue();
    }
}

void drawUI(sfRenderWindow* window, sfText* scoreText, sfCircleShape* judgementCircle) {
    char scoreString[200];
    snprintf(scoreString, sizeof(scoreString),
        "Score: %d\nGreat: %d\nGood: %d\nMiss: %d\nCombo: %d\nMax Combo: %d",
        stats.total_score, stats.great_count, stats.good_count, stats.miss_count,
        stats.current_combo, stats.max_combo);
    sfText_setString(scoreText, scoreString);

    sfRenderWindow_drawCircleShape(window, judgementCircle, NULL);
    sfRenderWindow_drawText(window, scoreText, NULL);
}

int main() {
    sfRenderWindow* window = sfRenderWindow_create(
        (sfVideoMode) {
        SCREEN_WIDTH, SCREEN_HEIGHT, 32
    },
        "Taiko Simulation",
        sfResize | sfClose,
        NULL
    );
    if (!window) return 1;

    // 載入資源
    sfTexture* bgTexture = sfTexture_createFromFile("bg_genre_2.png", NULL);
    if (!bgTexture) {
        printf("無法加載背景圖片！\n");
        return 1;
    }
    sfSprite* bgSprite = sfSprite_create();
    sfSprite_setTexture(bgSprite, bgTexture, sfTrue);

    redDrumTexture = sfTexture_createFromFile("red_note.png", NULL);
    if (!redDrumTexture) {
        printf("無法加載紅色鼓面圖片！\n");
        return 1;
    }

    blueDrumTexture = sfTexture_createFromFile("blue_note.png", NULL);
    if (!blueDrumTexture) {
        printf("無法加載藍色鼓面圖片！\n");
        return 1;
    }

    sfFont* font = sfFont_createFromFile("Taiko_No_Tatsujin_Official_Font.ttf");
    if (!font) {
        printf("無法加載字體！\n");
        return 1;
    }

    sfText* scoreText = sfText_create();
    sfText_setFont(scoreText, font);
    sfText_setCharacterSize(scoreText, 24);
    sfText_setFillColor(scoreText, sfBlack);
    sfText_setPosition(scoreText, (sfVector2f) { 10, 10 });

    sfCircleShape* judgementCircle = createJudgementCircle();

    // 倒數計時文字
    sfText* countdownText = sfText_create();
    sfText_setFont(countdownText, font);
    sfText_setCharacterSize(countdownText, 72);
    sfText_setFillColor(countdownText, sfBlack);
    sfText_setPosition(countdownText,
        (sfVector2f) {
        SCREEN_WIDTH / 2 - 36, SCREEN_HEIGHT / 2 - 36
    });

    parseNoteChart("yoasobi.txt");

    // 載入音樂但先不播放
    sfMusic* music = sfMusic_createFromFile("Yoru ni Kakeru.ogg");
    if (!music) {
        printf("無法加載音樂檔案！\n");
        return 1;
    }

    sfClock* gameClock = sfClock_create();
    int currentNoteIndex = 0;
    float gameStartTime = INITIAL_DELAY;
    bool gameStarted = false;


    sfEvent event;
    while (sfRenderWindow_isOpen(window)) {
        float currentTime = sfClock_getElapsedTime(gameClock).microseconds / 1000000.0f;

        if (!gameStarted) {
            int countdown = (int)(INITIAL_DELAY - currentTime + 1);
            if (countdown > 0) {
				//sfSleep(sfMilliseconds(1000));  // 使用sfMilliseconds
                char countdownStr[2];
                sprintf_s(countdownStr, sizeof(countdownStr), "%d", countdown);  // 使用sprintf_s
                sfText_setString(countdownText, countdownStr);
            }
            else {
				printf("遊戲開始！\n");
                printf("currentTime: %f, offset: %f", currentTime, musicInfo.offset);
                if (musicInfo.offset < 0) {
                    sfMusic_play(music);
                    sfSleep(sfSeconds(-musicInfo.offset));  // 等待 offset 時間
                    gameStartTime = currentTime + (-musicInfo.offset);  // 更新遊戲開始時間
                }
                else if (!(sfMusic_getStatus(music) == sfPlaying) &&
                    currentTime >= musicInfo.offset && musicInfo.offset > 0) {
                    sfMusic_play(music);
                }
                gameStarted = true;  // 設定遊戲已開始
            }
        }

        while (sfRenderWindow_pollEvent(window, &event)) {
            if (event.type == sfEvtClosed) {
                sfRenderWindow_close(window);
            }
            if (event.type == sfEvtKeyPressed && gameStarted) {
                switch (event.key.code) {
                case sfKeyF:
                case sfKeyJ:
                    processHit(1, currentTime - gameStartTime);
                    break;
                case sfKeyD:
                case sfKeyK:
                    processHit(2, currentTime - gameStartTime);
                    break;
                }
            }
        }

        // 遊戲開始後的邏輯
        if (gameStarted) {
            float gameTime = currentTime - gameStartTime;

            // 檢查是否需要生成新音符
            while (currentNoteIndex < totalNotes &&
                currentTime >= noteTimes[currentNoteIndex]) {
                if (notes[currentNoteIndex] != 0) {
                    spawnDrum(notes[currentNoteIndex], noteTimes[currentNoteIndex]);
                }
                currentNoteIndex++;
            }

            updateDrums(gameTime);
        }

        // 繪製
        sfRenderWindow_clear(window, sfBlack);
        sfRenderWindow_drawSprite(window, bgSprite, NULL);

        int count = size;
        int index = front;
        while (count > 0) {
            sfRenderWindow_drawSprite(window, drumQueue[index].sprite, NULL);
            index = (index + 1) % MAX_DRUMS;
            count--;
        }

        if (!gameStarted) {
            sfRenderWindow_drawText(window, countdownText, NULL);
        }

        drawUI(window, scoreText, judgementCircle);
        sfRenderWindow_display(window);

        if (currentNoteIndex >= totalNotes && isQueueEmpty()) {
            printf("遊戲結束！\n");
            break;
        }
    }

    // 清理資源
    while (!isQueueEmpty()) {
        dequeue();
    }
    sfClock_destroy(gameClock);
    sfMusic_destroy(music);
    sfSprite_destroy(bgSprite);
    sfTexture_destroy(bgTexture);
    sfTexture_destroy(redDrumTexture);
    sfTexture_destroy(blueDrumTexture);
    sfText_destroy(countdownText);
    sfRenderWindow_destroy(window);

    return 0;
}


